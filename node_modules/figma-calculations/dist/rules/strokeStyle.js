"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const exact_1 = require("./utils/exact");
const lookup_1 = __importDefault(require("./utils/lookup"));
const rgbToHex_1 = __importDefault(require("../utils/rgbToHex"));
const jsonpath_1 = __importDefault(require("jsonpath"));
function checkStrokeStyleMatch(styleBucket, targetNode, opts) {
    // decrement the count, or increment depending on what we find
    const checkName = "Stroke-Fill-Style";
    if (!(0, _1.isNodeOfTypeAndVisible)(["RECTANGLE", "ELLISPE"], targetNode))
        return { checkName, matchLevel: "Skip", suggestions: [] };
    // if a stroke doesn't exist in the first place, it's a skip
    if (targetNode.strokes.length === 0) {
        return { checkName, matchLevel: "Skip", suggestions: [] };
    }
    // check if style is exact match
    const exactMatch = (0, exact_1.isExactStyleMatch)("STROKE", styleBucket, targetNode);
    if (exactMatch)
        return {
            checkName,
            matchLevel: "Full",
            suggestions: [],
            exactMatch: { key: exactMatch.key },
        };
    const fillRGB = ["r", "g", "b"].map((letter) => jsonpath_1.default.query(targetNode, `$.strokes[0].color.${letter}`)[0]);
    // get the hex code
    const hex = (0, rgbToHex_1.default)(fillRGB[0], fillRGB[1], fillRGB[2]);
    if (opts === null || opts === void 0 ? void 0 : opts.hexStyleMap) {
        const { hexStyleMap } = opts;
        const suggestions = [];
        if (hexStyleMap[hex]) {
            const styleKeys = hexStyleMap[hex];
            const styleKey = targetNode.type === "TEXT" ? styleKeys.text : styleKeys.fill;
            if (styleKey) {
                suggestions.push({
                    message: `Color Override Exists in Library for hex ${hex}`,
                    styleKey,
                });
            }
            return { matchLevel: "Partial", checkName, suggestions };
        }
    }
    if (opts === null || opts === void 0 ? void 0 : opts.styleLookupMap) {
        const { matchLevel, suggestions } = (0, lookup_1.default)(checkName, opts.styleLookupMap, "STROKE", targetNode);
        return { checkName, matchLevel, suggestions };
    }
    return { checkName, matchLevel: "None", suggestions: [] };
}
exports.default = checkStrokeStyleMatch;
