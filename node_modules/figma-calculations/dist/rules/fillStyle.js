"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsonpath_1 = __importDefault(require("jsonpath"));
const _1 = require(".");
const exact_1 = require("./utils/exact");
const rgbToHex_1 = __importDefault(require("../utils/rgbToHex"));
const lookup_1 = __importDefault(require("./utils/lookup"));
function checkFillStyleMatch(styleBucket, targetNode, opts) {
    // decrement the count, or increment depending on what we find
    const checkName = "Fill-Style";
    // check if correct Node Type
    if (!(0, _1.isNodeOfTypeAndVisible)(["TEXT", "RECTANGLE", "ELLIPSE", "POLYGON", "INSTANCE"], targetNode))
        return { checkName, matchLevel: "Skip", suggestions: [] };
    // check if style is exact match
    const exactMatch = (0, exact_1.isExactStyleMatch)("FILL", styleBucket, targetNode);
    if (exactMatch)
        return {
            checkName,
            matchLevel: "Full",
            suggestions: [],
            exactMatch: { key: exactMatch.key },
        };
    // ignore fills if they have images
    const fillTypes = jsonpath_1.default.query(targetNode, "$.fills[*].type");
    if (fillTypes.includes("IMAGE")) {
        // ignore the node, image fills can be weird
        return { checkName, matchLevel: "Skip", suggestions: [] };
    }
    // if no fills exists to begin with, skip it
    if (fillTypes.length === 0) {
        // ignore the node, no fill ever existed
        return { checkName, matchLevel: "Skip", suggestions: [] };
    }
    const fillRGB = ["r", "g", "b"].map((letter) => jsonpath_1.default.query(targetNode, `$.fills[0].color.${letter}`)[0]);
    // get the hex code
    const hex = (0, rgbToHex_1.default)(fillRGB[0], fillRGB[1], fillRGB[2]);
    if (opts === null || opts === void 0 ? void 0 : opts.hexStyleMap) {
        const { hexStyleMap } = opts;
        const suggestions = [];
        if (hexStyleMap[hex]) {
            const styleKeys = hexStyleMap[hex];
            const styleKey = targetNode.type === "TEXT" ? styleKeys.text : styleKeys.fill;
            if (styleKey) {
                suggestions.push({
                    message: `Color Override Exists in Library for hex ${hex}`,
                    styleKey,
                });
            }
            return { matchLevel: "Partial", checkName, suggestions };
        }
    }
    if (opts === null || opts === void 0 ? void 0 : opts.styleLookupMap) {
        const { matchLevel, suggestions } = (0, lookup_1.default)(checkName, opts.styleLookupMap, "FILL", targetNode);
        return { checkName, matchLevel, suggestions };
    }
    return { checkName, matchLevel: "None", suggestions: [] };
}
exports.default = checkFillStyleMatch;
