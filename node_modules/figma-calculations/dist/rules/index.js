"use strict";
/* eslint-disable no-undef */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateComponentMap = exports.generateStyleLookup = exports.getStyleLookupKey = exports.getStyleLookupDefinitions = exports.generateStyleBucket = exports.isNodeOfTypeAndVisible = exports.runSimilarityChecks = void 0;
const jsonpath_1 = __importDefault(require("jsonpath"));
const fillStyle_1 = __importDefault(require("./fillStyle"));
const strokeStyle_1 = __importDefault(require("./strokeStyle"));
const textStyle_1 = __importDefault(require("./textStyle"));
/**
 * Run through all partial matches, and make exceptions depending on rules
 */
const runSimilarityChecks = (styleBucket, targetNode, opts) => {
    const checks = [
        textStyle_1.default,
        strokeStyle_1.default,
        fillStyle_1.default,
    ];
    const results = [];
    for (const check of checks) {
        const lintCheck = check(styleBucket, targetNode, opts);
        results.push(lintCheck);
    }
    return results;
};
exports.runSimilarityChecks = runSimilarityChecks;
/**
 * Check if a Node Type overlaps
 * @param types
 * @param node
 * @returns
 */
function isNodeOfTypeAndVisible(types, node) {
    return types.includes(node.type);
}
exports.isNodeOfTypeAndVisible = isNodeOfTypeAndVisible;
/**
 *
 * @param styles
 * @returns Object with style type and key as indexer
 * @description Creates a map of styles by name
 */
function generateStyleBucket(styles, opts) {
    // create hashmap of styles by styleType
    const styleBuckets = {};
    for (const style of styles) {
        if (!styleBuckets[style.style_type]) {
            styleBuckets[style.style_type] = {};
        }
        styleBuckets[style.style_type][style.key] = style;
        if (opts === null || opts === void 0 ? void 0 : opts.includeNames) {
            // use the style name as the key
            // serializing this may create duplicate, in memory, they should ref. the same object
            styleBuckets[style.style_type][style.name] = style;
        }
    }
    return styleBuckets;
}
exports.generateStyleBucket = generateStyleBucket;
function getStyleLookupDefinitions(styleType) {
    // sometimes the cloud and figma file diverge in naming
    // figmaPath is the path in the figma file
    // nodePath is the path in the cloud file (used by default)
    const FillLookupKeys = [
        {
            stylePath: "$.fills[0].color.r",
            nodePath: "$.fills[0].color.r",
            matchType: "exact",
        },
        {
            stylePath: "$.fills[0].color.g",
            nodePath: "$.fills[0].color.g",
            matchType: "exact",
        },
        {
            stylePath: "$.fills[0].color.b",
            nodePath: "$.fills[0].color.b",
            matchType: "exact",
        },
        {
            stylePath: "$.fills[0].color.a",
            nodePath: "$.fills[0].color.a",
            figmaPath: "$.fills[0].opacity",
            matchType: "exact",
        },
    ];
    const TextLookupKeys = [
        {
            stylePath: "$.style.fontFamily",
            nodePath: "$.style.fontFamily",
            figmaPath: "$.fontName.family",
            matchType: "exact",
            removeSpaces: true,
        },
        {
            stylePath: "$.style.fontSize",
            nodePath: "$.style.fontSize",
            figmaPath: "$.fontSize",
            matchType: "exact",
        },
        {
            stylePath: "$.style.fontPostScriptName",
            nodePath: "$.style.fontPostScriptName",
            figmaPath: "$.fontName.style",
            matchType: "includes",
        },
    ];
    const StrokeLookupKeys = [
        {
            stylePath: "$.fills[0].color.r",
            nodePath: "$.strokes[0].color.r",
            matchType: "exact",
        },
        {
            stylePath: "$.fills[0].color.g",
            nodePath: "$.strokes[0].color.g",
            matchType: "exact",
        },
        {
            stylePath: "$.fills[0].color.b",
            nodePath: "$.strokes[0].color.b",
            matchType: "exact",
        },
        {
            stylePath: "$.fills[0].color.a",
            nodePath: "$.strokes[0].color.a",
            figmaPath: "$.strokes[0].opacity",
            matchType: "exact",
        },
    ];
    if (styleType === "STROKE")
        return StrokeLookupKeys;
    if (styleType === "FILL")
        return FillLookupKeys;
    if (styleType === "TEXT")
        return TextLookupKeys;
    return undefined;
}
exports.getStyleLookupDefinitions = getStyleLookupDefinitions;
function getStyleLookupKey(checks, node, nodeType) {
    const key = [];
    for (const check of checks) {
        if (check.matchType === "exact") {
            let path = check.stylePath;
            // if we're looking at a figma path
            if (nodeType === "figmaNode") {
                path =
                    typeof figma === "undefined"
                        ? check.nodePath
                        : check.figmaPath || check.nodePath;
            }
            let styleValue = jsonpath_1.default.value(node, path);
            if (styleValue !== undefined &&
                (typeof styleValue === "string" || typeof styleValue === "number")) {
                // an option to clean
                if (check.removeSpaces && typeof styleValue === "string") {
                    styleValue = styleValue.split(" ").join("");
                }
                key.push(styleValue);
            }
            else {
                if (nodeType === "styleNode") {
                    // console.log(`Partial matches not supported for: ${node.name} }`);
                }
            }
        }
    }
    if (key.length == 0)
        return "";
    return key.join("<->");
}
exports.getStyleLookupKey = getStyleLookupKey;
function generateStyleLookup(styleBucket) {
    const styleLookupMap = {};
    const addStyleToValueMap = (type, styleValue, style) => {
        if (!styleLookupMap[type]) {
            styleLookupMap[type] = {};
        }
        if (!styleLookupMap[type][styleValue]) {
            styleLookupMap[type][styleValue] = [];
        }
        styleLookupMap[type][styleValue].push(style);
    };
    for (const type of Object.keys(styleBucket)) {
        const checks = getStyleLookupDefinitions(type);
        for (const styleKey of Object.keys(styleBucket[type])) {
            const style = styleBucket[type][styleKey];
            if (checks) {
                // dynamic key from the definition
                const key = getStyleLookupKey(checks, style.nodeDetails, "styleNode");
                if (key) {
                    addStyleToValueMap(type, key, style);
                }
            }
        }
        /*switch (type) {
            case "TEXT":
              {
                // use the font name
                const styleValue = jp.value(
                  style.nodeDetails,
                  "$.style.fontFamily"
                );
                if (styleValue) {
                  addStyleToValueMap(type, styleValue, style);
                }
              }
              break;
            case "FILL":
              {
                // use the fill hex code - no alpha channel
    
                const styleValue = jp.value(style.nodeDetails, "$.fills[0].color");
                if (styleValue) {
                  // color is a {r, g,b} obj
                  const hex = figmaRGBToHex(
                    styleValue.r,
                    styleValue.g,
                    styleValue.b
                  );
                  addStyleToValueMap(type, hex, style);
                }
              }
              break;
          }*/
    }
    return styleLookupMap;
}
exports.generateStyleLookup = generateStyleLookup;
/**
 *
 * @param styles
 * @returns Object with style name as key and style as value
 * @description Creates a map of styles by name
 */
function generateComponentMap(components) {
    // create hashmap of styles by styleType
    const componentBucket = {};
    // create a map of the team components by their key
    for (const comp of components) {
        const getComponentReadableName = () => {
            if (comp.name.includes("=")) {
                return comp.containing_frame.name;
            }
            return comp.name;
        };
        if (componentBucket)
            componentBucket[comp.key] = { name: getComponentReadableName() };
    }
    return componentBucket;
}
exports.generateComponentMap = generateComponentMap;
