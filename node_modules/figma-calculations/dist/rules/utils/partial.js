"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsonpath_1 = __importDefault(require("jsonpath"));
/**
 * Check if any sub properties overlap and amtch
 * @param checkName
 * @param styles
 * @param propertiesToCheck
 * @param targetNode
 * @returns
 */
function getPartialStyleMatches(checkName, stylesBucket, styleType, propertiesToCheck, targetNode, opts) {
    const suggestions = [];
    const styles = stylesBucket[styleType];
    //return { checkName, matchLevel: "None", suggestions: [] };
    const checkPropertyValue = (property, styleValue, targetValue, styleNode) => {
        if (property.removeSpaces) {
            styleValue = styleValue.split(" ").join("");
            targetValue = targetValue.split(" ").join("");
        }
        // sometimes it may not be a string, and is a figma partial
        if (typeof styleValue === "string") {
            if (property.matchType == "exact") {
                if (targetValue == styleValue) {
                    return {
                        message: `Possible Gestalt ${property.name || checkName} match with name: ${styleNode.name}`,
                        styleKey: styleNode.key,
                    };
                }
            }
            else {
                if (styleValue.includes(targetValue)) {
                    return {
                        message: `Possible Gestalt ${property.name || checkName} match with name: ${styleNode.name}`,
                        styleKey: styleNode.key,
                    };
                }
            }
        }
        if (typeof styleValue === "number") {
            if (property.matchType == "exact") {
                if (targetValue == styleValue) {
                    return {
                        message: `Possible Gestalt ${property.name || checkName} match with name: ${styleNode.name}`,
                        styleKey: styleNode.key,
                    };
                }
            }
            else {
                // handle partial rgb matching with close vicinity...
                return undefined;
            }
        }
        return undefined;
    };
    // check against all of styles, and that field in a style
    for (const styleId of Object.keys(styles)) {
        const styleNode = styles[styleId];
        let numPropMatches = 0;
        for (const property of propertiesToCheck) {
            const styleValue = jsonpath_1.default.value(styleNode.nodeDetails, property.stylePath);
            // skip it
            if (styleValue === undefined || styleValue === null)
                continue;
            // depending on the environment read the right path from the node
            const pathToUse = typeof figma === "undefined"
                ? property.nodePath
                : property.figmaPath || property.nodePath;
            const targetValue = jsonpath_1.default.value(targetNode, pathToUse);
            if (targetValue === undefined || targetValue === null)
                continue;
            //  console.log(pathToUse, styleValue, targetValue);
            const result = checkPropertyValue(property, styleValue, targetValue, styleNode);
            if (!result)
                continue;
            numPropMatches += 1;
            if (opts === null || opts === void 0 ? void 0 : opts.union) {
                // if all matches give a suggestion, then it's a union match
                if (numPropMatches === propertiesToCheck.length) {
                    suggestions.push(result);
                }
            }
            else {
                suggestions.push(result);
            }
        }
    }
    if (suggestions.length === 0) {
        return { checkName, matchLevel: "None", suggestions: [] };
    }
    return { checkName, matchLevel: "Partial", suggestions };
}
exports.default = getPartialStyleMatches;
