"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FigmaCalculator = void 0;
const parser_1 = __importDefault(require("./parser"));
const rules_1 = require("./rules");
const cleaners_1 = __importDefault(require("./rules/cleaners"));
const percent_1 = require("./utils/percent");
const process_1 = require("./utils/process");
const teams_1 = require("./utils/teams");
const webapi_1 = require("./webapi");
// exporting the types to reuse
__exportStar(require("./models/stats"), exports);
__exportStar(require("./models/figma"), exports);
__exportStar(require("./rules/cleaners"), exports);
class FigmaCalculator extends parser_1.default {
    constructor() {
        super(undefined);
        this.components = [];
        this.allStyles = [];
        this.apiToken = "";
        this.getFilesForTeams = teams_1.getFigmaPagesForTeam;
        /**
         * Runs a set of cleanup functions like removing unused nodes and fills to cleanup a file.
         * WARNING: Running this in a Figma Context will modify your files! Run figma.commitUndo prior
         */
        this.cleanupTree = cleaners_1.default.run;
        // initialize the parser with the root figma node in a plugin environment
        if (typeof figma !== "undefined") {
            this.setDocumentNode(figma.root);
        }
    }
    setAPIToken(apiToken) {
        this.apiToken = apiToken;
        webapi_1.FigmaAPIHelper.setToken(apiToken);
    }
    /**
     * Fetches a cloud file, and also does some pre-processing to merge Figma Node and Style Keys for easier lookups
     * @param fileKey - {string}
     * @returns
     */
    fetchCloudDocument(fileKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = yield webapi_1.FigmaAPIHelper.getFile(fileKey);
            const { document, styles, components, componentSets } = file;
            // look at the children and fix the styles to use the actual style key instead of node key
            FigmaCalculator.FindAll(document, (node) => {
                var _a, _b, _c;
                const cloudNode = node;
                for (const key in cloudNode.styles) {
                    const styleNodeId = cloudNode.styles[key];
                    if (cloudNode.styles[key]) {
                        // replace the style node id with the actual style key returned in the styles map
                        cloudNode.styles[key] = (_a = styles[styleNodeId]) === null || _a === void 0 ? void 0 : _a.key;
                    }
                }
                // to-do: replace all of the "componentIDs" with the actual component key or frame name
                if (cloudNode.componentId) {
                    const componentKey = ((_b = components[cloudNode.componentId]) === null || _b === void 0 ? void 0 : _b.key) ||
                        ((_c = componentSets[cloudNode.componentId]) === null || _c === void 0 ? void 0 : _c.key);
                    if (componentKey) {
                        cloudNode.componentId = componentKey;
                    }
                }
                return false;
            });
            this.setDocumentNode(document);
            if (!this.getDocumentNode()) {
                throw new Error("No document node or file key provided");
            }
            return file;
        });
    }
    /**
     * Load all of the components from the library
     * @param teamId - the team to load components from
     * @param {filterPrefixes} - an array of strings to throw out the components by
     */
    loadComponents(teamId, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.apiToken)
                throw new Error("No Figma API token provided");
            const teamComponents = yield webapi_1.FigmaAPIHelper.getTeamComponents(teamId);
            // variants live here
            const teamComponentSets = yield webapi_1.FigmaAPIHelper.getTeamComponentSets(teamId);
            this.components = teamComponents.concat(teamComponentSets);
            // throw out components that begin with a certain prefix (e..g all Handoff Components)
            if (opts && opts.filterPrefixes) {
                this.components = this.components.filter((comp) => {
                    // use the containing frame name instead if it's a variant
                    // Usually, these look like "name": "Count=5"
                    // Assuming we don't explicitly export components with an = signs in the name
                    if (comp.name.includes("=")) {
                        return opts.filterPrefixes.some((prefix) => comp.containing_frame.name
                            .toLowerCase()
                            .startsWith(prefix.toLowerCase()));
                    }
                    else {
                        return opts.filterPrefixes.some((prefix) => comp.name.toLowerCase().startsWith(prefix.toLowerCase()));
                    }
                });
            }
            return this.components;
        });
    }
    /**
     * Load all of the valid styles from your library
     *@param teamId - the team id to load styles from
     */
    loadStyles(teamId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.apiToken)
                throw new Error("No Figma API token provided");
            this.allStyles = yield webapi_1.FigmaAPIHelper.getTeamStyles(teamId);
            return this.allStyles;
        });
    }
    /**
     *
     * @param rootNode
     * @param opts
     * @returns ProcessedNode
     */
    getLintResults(node, opts) {
        let allStyles = this.allStyles || (opts === null || opts === void 0 ? void 0 : opts.styles);
        let styleBucket = (opts === null || opts === void 0 ? void 0 : opts.styleBucket) || FigmaCalculator.generateStyleBucket(allStyles);
        if (!styleBucket)
            throw new Error("No style bucket, or array of styles provided to generate lint results");
        return (0, rules_1.runSimilarityChecks)(styleBucket, node, opts);
    }
    static filterHiddenNodes(nodes) {
        let allHiddenNodes = [];
        const hiddenParentNodes = [];
        nodes.forEach((node) => {
            if (node.visible === false &&
                !allHiddenNodes.includes(node.id)) {
                hiddenParentNodes.push(node.id);
                // add all of the children as hidden nodes
                const subNodes = parser_1.default.FindAll(node, () => true);
                allHiddenNodes.push(node.id);
                subNodes.forEach((n) => allHiddenNodes.push(n.id));
            }
        });
        // we do our filtering on the second run because the order of nodes is unknown, and a child may appear before the parent
        const nonHiddenNodes = nodes.filter((n) => {
            // if the node is hidden, then toss it out
            if (allHiddenNodes.includes(n.id)) {
                return false;
            }
            return true;
        });
        return {
            hiddenParentNodes,
            nonHiddenNodes,
            numHiddenLayers: allHiddenNodes.length,
        };
    }
    /**
     *
     * @param rootNode
     * @param opts
     * @returns boolean
     * Looks at a set of node, and tosses out any nodes that belong to an instance node, and returns elements it finds
     */
    static filterLibraryNodes(nodes, opts) {
        // run through the page
        if (!(opts === null || opts === void 0 ? void 0 : opts.components))
            throw new Error("No components provided to filter out library nodes");
        const componentMap = (0, rules_1.generateComponentMap)(opts === null || opts === void 0 ? void 0 : opts.components);
        let allLibraryNodes = {};
        const filteredLibraryNodes = [];
        // get the component's real name
        // check if a component has a mainComponent?
        const isLibraryComponent = (instanceNode) => {
            // if it's a web file, then check the componentId else the mainCompponent property to get the key
            const componentKey = instanceNode.componentId || instanceNode.mainComponent.key;
            if (!componentKey) {
                return false;
            }
            if (componentMap[componentKey])
                return true;
            return false;
        };
        nodes.forEach((node) => {
            if (node.type === "INSTANCE" && isLibraryComponent(node)) {
                allLibraryNodes[node.id] = { layers: [], name: node.name };
                // note: this introduces hidden nodes as well (e.g. nodes that were not in the original set of nodes), hence the second pass
                const subNodes = parser_1.default.FindAll(node, () => true);
                subNodes.forEach((n) => allLibraryNodes[node.id].layers.push(n.id));
            }
        });
        const nonLibraryNodes = nodes.filter((n) => {
            for (const key in allLibraryNodes) {
                if (key === n.id || allLibraryNodes[key].layers.includes(n.id)) {
                    filteredLibraryNodes.push(n.id);
                    return false;
                }
            }
            return true;
        });
        return {
            nonLibraryNodes,
            libraryNodes: allLibraryNodes,
            numLibraryNodes: filteredLibraryNodes.length,
        };
    }
    /**
     * Looks through a given Figma tree and the checks and processes each of the nodes as individuals. Note: Hidden Nodes are thrown out
     * @param rootNode - Can pass any Figma Node with children
     * @param useEmitter - Streams the results of the process to the emitter in intervals
     */
    processTree(rootNode, opts) {
        const { components, allStyles } = opts || {};
        const { allHiddenNodes, libraryNodes, totalNodes, processedNodes } = (0, process_1.getProcessedNodes)(rootNode, components || this.components, allStyles || this.allStyles, opts);
        const aggregates = {
            totalNodes,
            hiddenNodes: allHiddenNodes,
            libraryNodes,
            checks: {},
        };
        // loop through the array and calculate the lint check totals
        for (const node of processedNodes) {
            for (const check of node.lintChecks) {
                if (!aggregates.checks[check.checkName]) {
                    aggregates.checks[check.checkName] = {
                        full: 0,
                        partial: 0,
                        skip: 0,
                        none: 0,
                    };
                }
                switch (check.matchLevel) {
                    case "Full":
                        {
                            aggregates.checks[check.checkName].full += 1;
                        }
                        break;
                    case "None":
                        {
                            aggregates.checks[check.checkName].none += 1;
                        }
                        break;
                    case "Partial":
                        {
                            aggregates.checks[check.checkName].partial += 1;
                        }
                        break;
                    case "Skip": {
                        aggregates.checks[check.checkName].skip += 1;
                    }
                }
            }
        }
        return {
            parentNode: {
                id: rootNode.id,
                name: rootNode.name,
            },
            aggregateCounts: aggregates,
        };
    }
    getAdoptionPercent(aggregates, opts) {
        const allTotals = {
            totalNodesOnPage: 0,
            totalNodesInLibrary: 0,
            totalMatchingText: 0,
        };
        for (const counts of aggregates) {
            const { totalNodes, libraryNodes, hiddenNodes, checks } = counts;
            allTotals.totalNodesOnPage += totalNodes - hiddenNodes;
            allTotals.totalNodesInLibrary += libraryNodes;
            if (checks["Text-Style"] && opts && opts.includeMatchingText) {
                allTotals.totalMatchingText += checks["Text-Style"].full;
            }
            if (checks["Text-Style"] && opts && opts.includePartialText) {
                allTotals.totalMatchingText += checks["Text-Style"].partial;
            }
        }
        const adoptionPercent = (0, percent_1.makePercent)((allTotals.totalNodesInLibrary + allTotals.totalMatchingText) /
            allTotals.totalNodesOnPage);
        return adoptionPercent;
    }
    /**
     * Get the percents of text style usage in files
     * @param processedNodes - array of nodes that have been processed
     */
    getTextStylePercentage(processedNodes, opts) {
        return (0, process_1.getLintCheckPercent)("Text-Style", processedNodes, {
            includePartials: (opts === null || opts === void 0 ? void 0 : opts.includePartialText) || false,
        });
    }
    /**
     * Get the percents of fill style usage in files
     * @param processedNodes - array of nodes that have been processed
     */
    getFillStylePercent(processedNodes, opts) {
        return (0, process_1.getLintCheckPercent)("Fill-Style", processedNodes, {
            includePartials: (opts === null || opts === void 0 ? void 0 : opts.includePartialFills) || false,
        });
    }
    /**
     * Get a breakdown of adoption percentages by team and project and how they rollup
     * @param allPages - a set of page details and figma file details with processed nodes
     */
    getBreakDownByTeams(pages, opts) {
        try {
            const teams = {};
            // build our team pages data structure which organizes into buckets
            for (const page of pages) {
                const projectName = page.file.projectName || "no-project";
                const teamName = page.file.teamName || "no-team";
                if (!teams[teamName]) {
                    teams[teamName] = {};
                }
                if (!teams[teamName][projectName]) {
                    teams[teamName][projectName] = { pages: [] };
                }
                teams[teamName][projectName].pages.push(page);
            }
            let allProcessedNodes = [];
            const processedPageStats = {};
            const processedProjectStats = {};
            const processedTeamStats = {};
            for (const team of Object.keys(teams)) {
                const projects = Object.keys(teams[team]);
                let teamProcessedNodes = [];
                for (const project of projects) {
                    const { pages } = teams[team][project];
                    const allProjectProcessedNodes = pages.map((page) => page.pageAggregates);
                    // initialize the project and page stats structure
                    if (!processedPageStats[team]) {
                        processedPageStats[team] = {};
                        processedProjectStats[team] = {};
                    }
                    // set the page stats
                    processedPageStats[team][project] = {
                        pages: pages.map((page) => {
                            return {
                                name: page.pageName,
                                key: page.file.key,
                                last_modified: page.file.last_modified,
                                adoptionPercent: this.getAdoptionPercent([page.pageAggregates], opts),
                                lintPercentages: {
                                    "Text-Style": this.getTextStylePercentage([page.pageAggregates], opts),
                                    "Fill-Style": this.getFillStylePercent([page.pageAggregates], opts),
                                },
                            };
                        }),
                    };
                    //  rollup the adoption percentages to project level stats
                    processedProjectStats[team][project] = {
                        adoptionPercent: this.getAdoptionPercent(allProjectProcessedNodes, opts),
                        lintPercentages: {
                            "Text-Style": this.getTextStylePercentage(allProjectProcessedNodes, opts),
                            "Fill-Style": this.getFillStylePercent(allProjectProcessedNodes, opts),
                        },
                    };
                    teamProcessedNodes = teamProcessedNodes.concat(allProjectProcessedNodes);
                }
                // rollup the adoption percentages to the team level stats
                processedTeamStats[team] = {
                    adoptionPercent: this.getAdoptionPercent(teamProcessedNodes, opts),
                    lintPercentages: {
                        "Text-Style": this.getTextStylePercentage(teamProcessedNodes, opts),
                        "Fill-Style": this.getFillStylePercent(teamProcessedNodes, opts),
                    },
                };
                allProcessedNodes = allProcessedNodes.concat(teamProcessedNodes);
            }
            // calculate a final adoption score with all of the nodes
            const totals = {
                adoptionPercent: this.getAdoptionPercent(allProcessedNodes, opts),
                lintPercentages: {
                    "Text-Style": this.getTextStylePercentage(allProcessedNodes, opts),
                    "Fill-Style": this.getFillStylePercent(allProcessedNodes, opts),
                },
            };
            return {
                totals,
                teams: processedTeamStats,
                projects: processedProjectStats,
                pages: processedPageStats,
            };
        }
        catch (ex) {
            throw ex;
        }
    }
}
exports.FigmaCalculator = FigmaCalculator;
FigmaCalculator.generateStyleBucket = rules_1.generateStyleBucket;
FigmaCalculator.generateStyleLookup = rules_1.generateStyleLookup;
FigmaCalculator.generateComponentMap = rules_1.generateComponentMap;
