"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FigmaAPIHelper = void 0;
const BASE_URL = "https://api.figma.com/v1";
const axios_1 = __importDefault(require("axios"));
/**
 * Static class used to call the REST API
 */
class FigmaAPIHelper {
    static setToken(token) {
        FigmaAPIHelper.API_TOKEN = token;
    }
    static getTeamProjects(teamIds) {
        return __awaiter(this, void 0, void 0, function* () {
            let projects = [];
            for (const teamId of teamIds) {
                const resp = yield axios_1.default.get(`${BASE_URL}/teams/${teamId}/projects`, {
                    headers: {
                        "X-FIGMA-TOKEN": FigmaAPIHelper.API_TOKEN,
                    },
                });
                const data = resp.data;
                if (!data.error && data.projects) {
                    projects = projects.concat(data);
                }
            }
            return projects;
        });
    }
    static getProjectFiles(projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            let files = [];
            const resp = yield axios_1.default.get(`${BASE_URL}/projects/${projectId}/files`, {
                headers: {
                    "X-FIGMA-TOKEN": FigmaAPIHelper.API_TOKEN,
                },
            });
            const data = resp.data;
            if (!data.error && data.files) {
                files = files.concat(data.files);
            }
            return files;
        });
    }
    static getFile(fileKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield axios_1.default.get(`${BASE_URL}/files/${fileKey}`, {
                headers: {
                    "X-FIGMA-TOKEN": FigmaAPIHelper.API_TOKEN,
                },
            });
            const data = resp.data;
            return data;
        });
    }
    static getFileHistory(fileKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield axios_1.default.get(`${BASE_URL}/files/${fileKey}/versions`, {
                headers: {
                    "X-FIGMA-TOKEN": FigmaAPIHelper.API_TOKEN,
                },
            });
            const data = resp.data.versions;
            return data;
        });
    }
    static getTeamComponentSets(teamId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let components = [];
            let nextCursor = undefined;
            do {
                const resp = yield axios_1.default.get(`${BASE_URL}/teams/${teamId}/component_sets`, {
                    headers: {
                        "X-FIGMA-TOKEN": FigmaAPIHelper.API_TOKEN,
                    },
                    params: {
                        after: nextCursor,
                        page_size: 10000,
                    },
                });
                const data = resp.data;
                const metadata = data.meta;
                nextCursor = (_a = metadata.cursor) === null || _a === void 0 ? void 0 : _a.after;
                if (!data.error && metadata.component_sets) {
                    components = components.concat(metadata.component_sets);
                }
            } while (nextCursor);
            return components;
        });
    }
    static getTeamComponents(teamId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let components = [];
            let nextCursor = undefined;
            do {
                const resp = yield axios_1.default.get(`${BASE_URL}/teams/${teamId}/components`, {
                    headers: {
                        "X-FIGMA-TOKEN": FigmaAPIHelper.API_TOKEN,
                    },
                    params: {
                        after: nextCursor,
                        page_size: 10000,
                    },
                });
                const data = resp.data;
                const metadata = data.meta;
                nextCursor = (_a = metadata.cursor) === null || _a === void 0 ? void 0 : _a.after;
                if (!data.error && metadata.components) {
                    components = components.concat(metadata.components);
                }
            } while (nextCursor);
            return components;
        });
    }
    static getTeamStyles(teamId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let styles = [];
            let nextCursor = undefined;
            do {
                const resp = yield axios_1.default.get(`${BASE_URL}/teams/${teamId}/styles`, {
                    headers: {
                        "X-FIGMA-TOKEN": FigmaAPIHelper.API_TOKEN,
                    },
                    params: {
                        after: nextCursor,
                        page_size: 10000,
                    },
                });
                const data = resp.data;
                const metadata = data.meta;
                nextCursor = (_a = metadata.cursor) === null || _a === void 0 ? void 0 : _a.after;
                if (!data.error && metadata.styles) {
                    styles = styles.concat(metadata.styles);
                }
            } while (nextCursor);
            const extendedStyles = [];
            // since styles can come from different files, sort the ids into the right fileId/nodeId buckets
            const { fileBuckets, nodeIdMap } = this.createFileBuckets(styles);
            // get node details from a specific file
            for (const fileKey of Object.keys(fileBuckets)) {
                const data = yield this.getNodeDetails(fileKey, fileBuckets[fileKey]);
                for (const id of fileBuckets[fileKey]) {
                    // text styles
                    const node = nodeIdMap[id];
                    node.nodeDetails = data.nodes[id].document;
                    extendedStyles.push(node);
                }
            }
            return extendedStyles;
        });
    }
    static getFileComponents(fileKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            let components = [];
            for (const fileId of fileKeys) {
                const resp = yield axios_1.default.get(`${BASE_URL}/files/${fileId}/components`, {
                    headers: {
                        "X-FIGMA-TOKEN": FigmaAPIHelper.API_TOKEN,
                    },
                });
                const data = resp.data;
                if (!data.error && data.meta.components) {
                    components = components.concat(data.meta.components);
                }
            }
            return components;
        });
    }
    static getFileStyles(fileKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            let styles = [];
            for (const fileId of fileKeys) {
                const resp = yield axios_1.default.get(`${BASE_URL}/files/${fileId}/styles`, {
                    headers: {
                        "X-FIGMA-TOKEN": FigmaAPIHelper.API_TOKEN,
                    },
                });
                const data = resp.data;
                if (!data.error && data.meta.styles) {
                    styles = styles.concat(data.meta.styles);
                }
            }
            const extendedStyles = [];
            // since styles can come from different files, sort the ids into the right fileId/nodeId buckets
            const { fileBuckets, nodeIdMap } = this.createFileBuckets(styles);
            for (const fileKey of Object.keys(fileBuckets)) {
                const data = yield this.getNodeDetails(fileKey, fileBuckets[fileKey]);
                for (const id of fileBuckets[fileKey]) {
                    // text styles
                    const node = nodeIdMap[id];
                    node.nodeDetails = data.nodes[id].document;
                    extendedStyles.push(node);
                }
            }
            return extendedStyles;
        });
    }
    static getNodeDetails(fileKey, nodeIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield axios_1.default.get(`${BASE_URL}/files/${fileKey}/nodes`, {
                headers: {
                    "X-FIGMA-TOKEN": FigmaAPIHelper.API_TOKEN,
                },
                params: {
                    ids: nodeIds.join(","),
                },
            });
            const data = resp.data;
            return data;
        });
    }
    /**
     * Breaks a list of styles into a relevant file key with styles so we can lookup by file
     */
    static createFileBuckets(sharedNodes) {
        const fileBuckets = {};
        const nodeIdMap = {};
        for (const style of sharedNodes) {
            if (!fileBuckets[style.file_key]) {
                fileBuckets[style.file_key] = [];
            }
            nodeIdMap[style.node_id] = style;
            fileBuckets[style.file_key].push(style.node_id);
        }
        return { nodeIdMap, fileBuckets };
    }
}
exports.FigmaAPIHelper = FigmaAPIHelper;
