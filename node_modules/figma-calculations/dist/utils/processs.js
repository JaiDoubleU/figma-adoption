"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLintCheckPercent = exports.getProcessedNodes = exports.getHiddenNodes = void 0;
const parser_1 = __importDefault(require("../parser"));
const rules_1 = require("../rules");
const percent_1 = require("./percent");
// returns array of nodes that are in a hidden layer tree
const getHiddenNodes = (topLevelHiddenNode) => {
    const childrenNodes = parser_1.default.FindAll(topLevelHiddenNode, (node) => true);
    return [topLevelHiddenNode].concat(childrenNodes);
};
exports.getHiddenNodes = getHiddenNodes;
function getProcessedNodes(rootNode, components, allStyles, onProcessNode) {
    // create a map of the team components by name
    const componentMap = (0, rules_1.generateComponentMap)(components);
    const styleBuckets = (0, rules_1.generateStyleBucket)(allStyles);
    let totalNodes = 0;
    const processedNodes = [];
    let libraryNodes = [];
    let nodesToSkip = [];
    let allHiddenNodes = [];
    const addToProcessedNodes = (node) => {
        if (onProcessNode) {
            onProcessNode(node);
        }
        processedNodes.push(node);
    };
    parser_1.default.FindAll(rootNode, (node) => {
        // returns array of nodes that are in a hidden layer tree
        if (node.visible === false) {
            const hiddenNodes = (0, exports.getHiddenNodes)(node).map((node) => node.id);
            allHiddenNodes = allHiddenNodes.concat(hiddenNodes);
            return false;
        }
        // if the node is hidden, then don't include it in our counts
        if (allHiddenNodes.includes(node.id)) {
            return false;
        }
        totalNodes += 1;
        // exclude any instance nodes
        if (nodesToSkip.includes(node.id)) {
            return false;
        }
        // get all the sublayers of an instance that's part of a library, and skip it
        if (node.type === "INSTANCE" && componentMap[node.name]) {
            totalNodes -= 1;
            addToProcessedNodes({
                id: node.id,
                name: node.name,
                type: node.type,
                lintChecks: [],
                belongsToLibraryComponent: true,
                similarComponents: [],
            });
            const subNodes = parser_1.default.FindAll(node, () => true);
            nodesToSkip = subNodes.map((n) => n.id);
            const hiddenSubNodes = subNodes
                .filter((node) => node.visible === false)
                .map((node) => (0, exports.getHiddenNodes)(node))
                .flat();
            const allHiddenNodesMap = {};
            for (const node of hiddenSubNodes) {
                allHiddenNodesMap[node.id] = "";
            }
            // anything that's not hidden is visible
            const visibleNodes = subNodes.filter((node) => !(node.id in allHiddenNodesMap));
            // all of the visible sub nodes of an instance node
            libraryNodes = libraryNodes.concat(visibleNodes);
            return false;
        }
        const result = (0, rules_1.runSimilarityChecks)(styleBuckets, node);
        addToProcessedNodes({
            id: node.id,
            name: node.name,
            type: node.type,
            lintChecks: result,
            belongsToLibraryComponent: false,
            similarComponents: [],
        });
        return true;
    });
    // throw in the subnodes of the instance nodes
    for (const node of libraryNodes) {
        addToProcessedNodes({
            id: node.id,
            name: node.name,
            type: node.type,
            lintChecks: [],
            belongsToLibraryComponent: true,
            similarComponents: [],
        });
    }
    return { processedNodes, libraryNodes, totalNodes, allHiddenNodes };
}
exports.getProcessedNodes = getProcessedNodes;
function getLintCheckPercent(checkName, aggregates) {
    const allTotals = {
        totalNodes: 0,
        totalFullMatch: 0,
        totalPartialMatch: 0,
    };
    for (const count of aggregates) {
        const { checks } = count;
        if (checks[checkName]) {
            const results = checks[checkName];
            allTotals.totalFullMatch += results.full;
            allTotals.totalPartialMatch += results.partial;
            allTotals.totalNodes += results.partial + results.full + results.none;
        }
    }
    return {
        checkName,
        full: (0, percent_1.makePercent)(allTotals.totalFullMatch / allTotals.totalNodes),
        partial: (0, percent_1.makePercent)(allTotals.totalPartialMatch / allTotals.totalNodes),
    };
}
exports.getLintCheckPercent = getLintCheckPercent;
