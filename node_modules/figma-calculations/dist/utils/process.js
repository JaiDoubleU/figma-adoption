"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLintCheckPercent = exports.getProcessedNodes = exports.getHiddenNodes = void 0;
const __1 = require("..");
const parser_1 = __importDefault(require("../parser"));
const rules_1 = require("../rules");
const percent_1 = require("./percent");
// returns array of nodes that are in a hidden layer tree
const getHiddenNodes = (topLevelHiddenNode) => {
    const childrenNodes = parser_1.default.FindAll(topLevelHiddenNode, (node) => true);
    return [topLevelHiddenNode].concat(childrenNodes);
};
exports.getHiddenNodes = getHiddenNodes;
function getProcessedNodes(rootNode, components, allStyles, opts) {
    const styleBuckets = (0, rules_1.generateStyleBucket)(allStyles);
    const styleLookupMap = (0, rules_1.generateStyleLookup)(styleBuckets);
    const processedNodes = [];
    const addToProcessedNodes = (node) => {
        if (opts === null || opts === void 0 ? void 0 : opts.onProcessNode) {
            opts.onProcessNode(node);
        }
        processedNodes.push(node);
    };
    // find all the nodes in the document
    const allNodes = parser_1.default.FindAll(rootNode, (n) => true);
    // toss any hidden nodes, get the counts
    const { nonHiddenNodes, numHiddenLayers } = __1.FigmaCalculator.filterHiddenNodes(allNodes);
    // toss any library nodes from the list
    const { nonLibraryNodes, numLibraryNodes, libraryNodes } = __1.FigmaCalculator.filterLibraryNodes(nonHiddenNodes, {
        components,
    });
    // also process the library nodes
    for (const nodeId of Object.keys(libraryNodes)) {
        const baseInstanceComponent = {
            name: libraryNodes[nodeId].name,
            type: "INSTANCE",
            lintChecks: [],
            belongsToLibraryComponent: true,
            similarComponents: [],
        };
        // add the top-level node
        addToProcessedNodes(Object.assign({ id: nodeId }, baseInstanceComponent));
        // add all the individual library nodes
        const { layers } = libraryNodes[nodeId];
        for (const layerNodeId of layers) {
            addToProcessedNodes(Object.assign({ id: layerNodeId }, baseInstanceComponent));
        }
    }
    // run lint checks on the remaning nodes
    for (const node of nonLibraryNodes) {
        const result = (0, rules_1.runSimilarityChecks)(styleBuckets, node, Object.assign({ styleLookupMap }, opts));
        addToProcessedNodes({
            id: node.id,
            name: node.name,
            type: node.type,
            lintChecks: result,
            belongsToLibraryComponent: false,
            similarComponents: [],
        });
    }
    return {
        processedNodes,
        totalNodes: allNodes.length,
        libraryNodes: numLibraryNodes,
        allHiddenNodes: numHiddenLayers,
    };
}
exports.getProcessedNodes = getProcessedNodes;
function getLintCheckPercent(checkName, aggregates, opts) {
    const allTotals = {
        totalNodes: 0,
        totalFullMatch: 0,
        totalPartialMatch: 0,
    };
    for (const count of aggregates) {
        const { checks, hiddenNodes } = count;
        if (checks[checkName]) {
            const results = checks[checkName];
            allTotals.totalFullMatch += results.full;
            allTotals.totalPartialMatch += results.partial;
            if (opts && opts.includePartials) {
                allTotals.totalFullMatch += results.partial;
            }
            allTotals.totalNodes += results.partial + results.full + results.none;
        }
    }
    return {
        checkName,
        full: (0, percent_1.makePercent)(allTotals.totalFullMatch / allTotals.totalNodes),
        partial: (0, percent_1.makePercent)(allTotals.totalPartialMatch / allTotals.totalNodes),
    };
}
exports.getLintCheckPercent = getLintCheckPercent;
